# The standard library
# ====================

# Functions filling in for parafunctions
# --------------------------------------

### Binary function realizing the logic of the and parafunc.
(bind f_and (func (x y) (and x y)))

### Binary function realizing the logic of the or parafunc.
(bind f_or (func (x y) (or x y)))

### Unary function realizing the logical negation.
(bind f_not (func (x) (not x)))

# Comparison operators
# --------------------

### Not equal in terms of equality
(bind ne (func (x y) (not (eq x y))))

### Greater than implemented in terms of less than and non-equality
(bind gt (func (x y) (lt y x)))

### Greater or equal implemented in terms of less than
(bind ge (func (x y) (not (lt x y))))

### Less or equal implemented in terms of greater than
(bind le (func (x y) (not (gt x y))))

# Reference operations
# --------------------

### Returns a given reference advanced by n steps
(bind succ_n (func (r^ n) (if (eq n 0) r^ (succ_n (succ r^) (- n 1)))))

### Returns distance between two references
(bind distance (func (first^ last^) (do
    (bind distance_impl (func (first^ last^ counter)
        (if (eq first^ last^)
            counter
            (distance_impl (succ first^) last^ (+ counter 1))
        )
    ))
    (distance_impl first^ last^ 0)
)))

### Swaps values pointed by two references using a temporary object.
(bind swap (func (x^ y^) (do
    (bind temp (peek x^))
    (poke x^ (peek y^))
    (poke y^ temp)
    unit
)))

# Compound operations
# -------------------

### Checks whether a compound structure is empty
(bind empty (func (x) (eq (length x) 0)))

### Returns the first element of a compound structure
(bind front (func (x) (at x 0)))

### Returns the last element of a compound structure
(bind back (func (x) (at x (- (length x) 1))))

### Returns the compound structure sans the first element
(bind tail (func (x) (slice x 1 (length x))))

### Returns the compound structure sans the last element
(bind rtail (func (x) (slice x 0 (- (length x) 1))))

### Deconstructs compound structure into a tuple containing
### the head and the tail of the input compound structure
(bind dcons (func (x) { (front x) (tail x) }))

### Deconstructs compound structure into a tuple containing
### the tail and the reverse tail of the input compound structure
(bind rdcons (func (x) { (back x) (rtail x) }))

# Functional helpers
# ------------------

### Function composition
(bind point (func (f g x) (g (f x))))

### Functional map
(bind map (func (f v)
    (if (empty v)
        v
        (push_front (map f (tail v)) (f (front v)))
    )
))

### Functional zip
(bind zip (func (vx vy) (do
	(bind zip_impl (func (vx vy result)
		(if (or (empty vx) (empty vy))
			result
			(do
				(bind { hdx tlx } (dcons vx))
				(bind { hdy tly } (dcons vy))
				(zip_impl tlx tly (push_back result { hdx hdy }))
			)
		)
	))
	(zip_impl vx vy [])
)))

### Functional map for two input collections
(bind zip_with (func (f va vb)
    (if (or (empty va) (empty vb))
        (slice va 0 0)
        (push_front
            (zip_with f (tail va) (tail vb))
            (f (front va) (front vb))
        )
    )
))

### Fold left
(bind foldl (func (f z v)
    (if (empty v)
        z
        (do
            (bind { hd tl } (dcons v))
            (foldl f (f z hd) tl)
        )
    )
))

### Fold right
(bind foldr (func (f z v)
    (if (empty v)
        z
        (do
            (bind { hd tl } (dcons v))
            (f hd (foldr f z tl))
        )
    )
))

# Algorithms
# ----------

### Returns the lesser of the two arguments based on the provided less than operator
(bind min_cmp (func (cmp x y) (if (cmp x y) x y)))
(bind min_ref_cmp (func (cmp x^ y^) (if (cmp (peek x^) (peek y^)) x^ y^)))

### Returns the lesser of the two arguments based on the less than operator
(bind min (min_cmp lt))
(bind min_ref (min_ref_cmp lt))

### Returns the greager of the two arguments based on the provided less than operator
(bind max_cmp (func (cmp x y) (if (cmp x y) y x)))
(bind max_ref_cmp (func (cmp x^ y^) (if (cmp (peek x^) (peek y^)) y^ x^)))

### Returns the greater of the two arguments based on the less than operator
(bind max (max_cmp lt))
(bind max_ref (max_ref_cmp lt))

### Finds the minimum element in a compound structure with a custom comparator
(bind min_element_cmp (func (cmp first^ last^) (do
    (bind min_element_impl (func (current_min^ first^ last^)
        (if (eq first^ last^)
            current_min^
            (min_element_impl
                (min_ref_cmp cmp current_min^ first^)
                (succ first^)
                last^
            )
        )
    ))
    (bind len (distance first^ last^))
    (if (eq len 0)
        last^
        (if (eq len 1)
            first^
            (min_element_impl first^ (succ first^) last^)
        )
    )
)))

### Finds the minimum element in a compound structure with a
### default comparator: less than
(bind min_element (min_element_cmp lt))

### Finds a reference to the first element in range that satisfies the provided
### predicate.
(bind find_if (func (first^ last^ pred)
    (if (or (eq first^ last^) (pred (peek first^)))
        first^
        (find_if (succ first^) last^ pred)
    )
))

### Finds a reference to the first element in range that doesn't satisfy
### the provided predicate.
(bind find_if_not (func (first^ last^ pred)
    (find_if first^ last^ (point pred not))
))

### Attempts to find a value in the given range
(bind find (func (first^ last^ value) (find_if first^ last^ (eq value))))

### Rearranges elements that all of them that fulfill the predicate end up
### between first and the returned references, and all others end up between
### the returned and the last references. Accepts custom comparator.
(bind partition (func (pred first^ last^) (do
    (bind mismatch^ (find_if_not first^ last^ pred))
    (if (eq mismatch^ last^)
        first^
        (do
            (bind match^ (find_if mismatch^ last^ pred))
            (if (eq match^ last^)
                mismatch^
                (do
                    (swap mismatch^ match^)
                    (partition pred (succ mismatch^) last^)
                )
            )
        )
    )
)))

### Inplace quicksort implementation accepting custom comparator
(bind quicksort_cmp (func (cmp first^ last^)
    (if (eq first^ last^)
        unit
        (do
            (bind pivot^ (succ_n first^ (/ (distance first^ last^) 2)))
            (bind lt_pivot (point (cmp (peek pivot^)) not))
            (bind ge_pivot (cmp (peek pivot^)))
            (bind middle_a^ (partition lt_pivot first^ last^))
            (bind middle_b^ (partition ge_pivot first^ last^))
            (quicksort_cmp cmp first^ middle_a^)
            (quicksort_cmp cmp middle_b^ last^)
            unit
        )
    )
))

### Quicksort algorithm variant for the default less than comparator
(bind quicksort (quicksort_cmp lt))

### Merges two sorted compound structures into a sorted one
### with a custom comparator
(bind merge_cmp (func (cmp x y) (do
    (bind merge_impl (func (x y result) (do
        (bind x_empty (empty x))
        (bind y_empty (empty y))
        (if x_empty
            (if y_empty result (cat result y))
            (if y_empty
                (cat result x)
                (if (cmp (front x) (front y))
                    (merge_impl (tail x) y (push_back result (front x)))
                    (merge_impl x (tail y) (push_back result (front y)))
                )
            )
        )
    )))
    (merge_impl x y (slice x 0 0)) # This slice creates empty array or tuple.
)))

### Merges two sorted compound structures into a sorted one.
### A default comparator less than assumed.
(bind merge (merge_cmp lt))

### Merge-sorts a compound structure with a custom comparator.
(bind merge_sort_cmp (func (cmp x) (do
    (bind len (length x))
    (bind half_len (/ len 2))
    (if (le len 1)
        x
        (merge_cmp
            cmp
            (merge_sort_cmp cmp (slice x 0 half_len))
            (merge_sort_cmp cmp (slice x half_len len))
        )
    )
)))

### Merge-sorts a compound structure with a default comparator: less than.
(bind merge_sort (merge_sort_cmp lt))

### Default sorting function accepting a comparison function as an argument.
(bind sort_cmp merge_sort_cmp)

### Default sorting function with the comparison defaulted to less than.
(bind sort (sort_cmp lt))

# Compound generators
# -------------------

### Produce sequence of first n natural numbers (including 0).
(bind seq (func (n) (do
	(bind seq_impl (func (current last acc)
		(if (eq current last)
			acc
			(seq_impl (+ current 1) last (push_back acc current))
		)
	))
	(seq_impl 0 n [])
)))

### Returns an array containing a range of integer values
(bind range_int (func (init count) (do
	(map (+ init) (seq count))
)))

# Text related
# ------------

### Prints a formatted string
(bind printf (func (fmt args) (print (format fmt args))))

# Automatic testing
# -----------------

(bind test (func (case result)
    (if result true (do (printf "Test \"%s\" failed\n" { case }) false))
))

(bind std_test (func ()
    (foldl f_and true [

        # Comparisons
        (test "Not equal 1" (eq (ne 1 2) true))
        (test "Not equal 2" (eq (ne 3 3) false))
        (test "Greater than 1" (eq (gt 3 2) true))
        (test "Greater than 2" (eq (gt 2 3) false))
        (test "Greater than or equal 1" (eq (ge 3 2) true))
        (test "Greater than or equal 2" (eq (ge 3 3) true))
        (test "Greater than or equal 3" (eq (ge 3 4) false))
        (test "Less than or equal 1" (eq (le 2 3) true))
        (test "Less than or equal 2" (eq (le 3 3) true))
        (test "Less than or equal 3" (eq (le 4 3) false))

        # References
        (test "Nth successor" (do
            (bind v [ 1 2 3 ])
            (bind tedious (succ (succ (begin v))))
            (bind easy (succ_n (begin v) 2))
            (and (eq tedious easy) (eq (peek tedious) (peek easy)))
        ))

        (test "Reference distance" (do
            (bind v [ 1 2 3 ])
            (eq (distance (begin v) (end v)) (length v))
        ))

        (test "Swap test" (do
            (bind x [ 1.0 2.0 3.0 ])
            (bind y [ 3.0 2.0 1.0 ])
            (swap (ref x) (ref y))
            (and (eq x [ 3.0 2.0 1.0 ]) (eq y [ 1.0 2.0 3.0 ]))
        ))

        # Compound clunky
        (test "String = array" (eq "string" [ 's' 't' 'r' 'i' 'n' 'g' ]))
        (test "Empty 1" (eq (empty []) true))
        (test "Empty 2" (eq (empty { 'a' }) false))
        (test "Empty 3" (eq (empty "") true))
        (test "Front 1" (eq (front [ 'a' ]) 'a'))
        (test "Front 2" (eq (front { 1.0 2.0 3.0 }) 1.0))
        (test "Back 1" (eq (back [ 'a' ]) 'a'))
        (test "Back 2" (eq (back [ 1.0 2.0 3.0 ]) 3.0))
        (test "Tail 1" (eq (tail { 'a' }) {}))
        (test "Tail 2" (eq (tail [ 1.0 2.0 3.0 ]) [ 2.0 3.0 ]))
        (test "Tail 3" (eq (tail "asd") "sd"))
        (test "Reverse tail 1" (eq (rtail { 'a' }) {}))
        (test "Reverse tail 2" (eq (rtail [ 1.0 2.0 3.0 ]) [ 1.0 2.0 ]))
        (test "Reverse tail 3" (eq (rtail "asd") "as"))
        (test "Deconstruct 1" (eq (dcons [ 1 2 3 ]) { 1 [ 2 3 ] }))
        (test "Deconstruct 2" (eq (dcons [ true ]) { true [] }))
        (test "Reverse deconstruct 1" (eq (rdcons [ 1 2 3 ]) { 3 [ 1 2 ] }))
        (test "Reverse deconstruct 2" (eq (rdcons [ true ]) { true [] }))
        (test "Push front 1" (eq (push_front [] 'a') [ 'a' ]))
        (test "Push front 2" (eq (push_front [ "due" "rabe" ] "ene") [ "ene" "due" "rabe" ]))
        (test "Push front 3" (eq (push_front "sd" 'a') "asd"))
        (test "Push back 1" (eq (push_back [] 'a') [ 'a' ]))
        (test "Push back 2" (eq (push_back [ "due" "rabe" ] "ene") [ "due" "rabe" "ene" ]))
        (test "Push back 3" (eq (push_back "sd" 'a') "sda"))

        # Compound reference based
        (test "End reference" (do
            (bind v [ 1 2 3 ])
            (bind tedious (succ (succ (succ (begin v)))))
            (bind easy (end v))
            (eq tedious easy)
        ))

        # Functional
        (test "Point 1" (do (bind cadr (point tail front)) (eq (cadr [ 1 2 3 ]) 2)))
        (test "Point 2" (do
            (bind times2 (* 2))
            (bind times4 (point times2 times2))
            (bind times8 (point times2 times4))
            (eq (times8 3) (* 3 8))
        ))
        (test "Map" (eq (map not [ true false true ]) [ false true false ]))
        (test "Zip with" (eq (zip_with * [ 1 2 3 ] [ 4 5 6 ]) [ 4 10 18 ]))
        (test "Fold left" (eq (foldl - 0 [ 1 2 3 4 5 6 7 8 9 10 ]) -55))
        (test "Fold right" (eq (foldr - 0 [ 1 2 3 4 5 6 7 8 9 10 ]) -5))
		(test "Zip normal" (eq (zip [ 1 2 3 ] [ 'a' 'b' 'c' ]) [ { 1 'a' } { 2 'b' } { 3 'c' } ]))
		(test "Zip count mismatch" (eq (zip [ 1 2 3 ] [ 'a' 'b' ]) [ { 1 'a' } { 2 'b' } ]))
		(test "Zip with empty" (eq (zip [ 1 2 3 ] []) []))

        # Algorithms simple
        (test "Min 1" (eq (min_cmp gt 1 2) 2))
        (test "Min 2" (eq (min_cmp lt 1 2) 1))
        (test "Min 3" (eq (min 5.0 500.0) 5.0))
        (test "Max 1" (eq (max_cmp gt 1 2) 1))
        (test "Max 2" (eq (max_cmp lt 1 2) 2))
        (test "Max 3" (eq (max 5.0 500.0) 500.0))

        # Algorithms compound reference

        (test "Min element 1" (do
            (bind v [ 1 2 3])
            (bind result_gt^ (min_element_cmp gt (begin v) (end v)))
            (eq (peek result_gt^) 3)
        ))
        (test "Min element 2" (do
            (bind v [ 1 2 3])
            (bind result_lt^ (min_element (begin v) (end v)))
            (eq (peek result_lt^) 1)
        ))

        (test "Find 1" (do
            (bind v "asdf")
            (bind result^ (find (begin v) (end v) 'd'))
            (eq (peek result^) 'd')
        ))
        (test "Find 2" (do
            (bind v "asdf")
            (bind result^ (find (begin v) (end v) 'z'))
            (eq result^ (end v))
        ))

        (test "Find if 1" (do
            (bind v "asdf")
            (bind result^ (find_if (begin v) (end v) (eq 'd')))
            (eq (peek result^) 'd')
        ))
        (test "Find if 2" (do
            (bind v "asdf")
            (bind result^ (find_if (begin v) (end v) (eq 'z')))
            (eq result^ (end v))
        ))

        (test "Find if not 1" (do
            (bind v [ 2 4 6 8 ])
            (bind result^ (find_if_not (begin v) (end v) (ge 5)))
            (eq (peek result^) 6)
        ))
        (test "Find if not 2" (do
            (bind v { 1.0 2.0 3.0 4.0 })
            (bind result^ (find_if_not (begin v) (end v) (ge 5.0)))
            (eq result^ (end v))
        ))

        (test "Partition mixed" (do
            (bind v [ 1 4 5 3 2 6 ])
            (bind result^ (partition (ge 3) (begin v) (end v)))
            (eq (peek result^) 4)
        ))

        (test "Merge 1" (eq (merge_cmp gt [ 5 3 1 ] [ 6 4 2 ]) [ 6 5 4 3 2 1 ]))
        (test "Merge 2" (eq (merge [ 1 3 5 ] [ 2 4 6 ]) [ 1 2 3 4 5 6 ]))
        (test "Sort 1" (eq (merge_sort_cmp gt [ 5 1 4 2 3 ]) [ 5 4 3 2 1 ]))
        (test "Sort 2" (eq (merge_sort [ 5 1 4 2 3 ]) [ 1 2 3 4 5 ]))

		# Sequences
		(test "Sequence empty" (eq (seq 0) []))
		(test "Sequence non-empty" (eq (seq 5) [ 0 1 2 3 4 ]))
		(test "Integer range empty" (eq (range_int 0 0) []))
		(test "Integer range positive" (eq (range_int 0 4) [ 0 1 2 3 ]))
		(test "Integer range not only positive" (eq (range_int -2 4) [ -2 -1 0 1 ]))
    ])
))

