### Not equal in terms of equality
(bind ne (func (x y) (not (eq x y))))

### Greater than implemented in terms of less than and non-equality
(bind gt (func (x y) (lt y x)))

### Greater or equal implemented in terms of less than
(bind ge (func (x y) (not (lt x y))))

### Less or equal implemented in terms of greater than
(bind le (func (x y) (not (gt x y))))

### Checks whether a compound structure is empty
(bind empty (func (x) (eq (length x) 0)))

### Returns the first element of a compound structure
(bind car (func (x) (at x 0)))

### Returns the compound structure sans the first element
(bind cdr (func (x) (slice x 1 (length x))))

### Returns the first element of a compound structure
(bind front (func (x) (at x 0)))

### Returns the last element of a compound structure
(bind back (func (x) (at x (- (length x) 1))))

### Constructs a new compound value from an element and an existing compound
(bind cons (func (x arr) (push_front arr x)))

### Deconstructs compound structure into a tuple containing
### the head and the tail of the input compound structure
(bind dcons (func (x) { (car x) (cdr x) }))

### Returns the lesser of the two arguments based on the provided less than operator
(bind min_cmp (func (x y cmp) (if (cmp x y) x y)))

### Returns the lesser of the two arguments based on the less than operator
(bind min (func (x y) (min_cmp x y lt)))

### Returns the greager of the two arguments based on the provided less than operator
(bind max_cmp (func (x y cmp) (if (cmp x y) y x)))

### Returns the greater of the two arguments based on the less than operator
(bind max (func (x y) (max_cmp x y lt)))

### Finds the minimum element in a compound structure with a custom comparator
(bind min_element_cmp (func (x cmp) (do
    (bind min_element_impl (func (element x)
        (if (empty x)
            element
            (if (cmp element (car x))
                (min_element_impl element (cdr x))
                (min_element_impl (car x) (cdr x))
            )
        )
    ))
    (if (eq (length x) 1)
        (car x)
        (min_element_impl (car x) (cdr x))
    )
)))

### Finds the minimum element in a compound structure with a
### default comparator: less than
(bind min_element (func (x) (min_element_cmp x lt)))

### Merges two sorted compound structures into a sorted one
### with a custom comparator
(bind merge_cmp (func (x y cmp) (do
    (bind merge_impl (func (x y result) (do
        (bind x_empty (empty x))
        (bind y_empty (empty y))
        (if x_empty
            (if y_empty result (cat result y))
            (if y_empty
                (cat result x)
                (if (cmp (car x) (car y))
                    (merge_impl (cdr x) y (cat result (slice x 0 1)))
                    (merge_impl x (cdr y) (cat result (slice y 0 1)))
                )
            )
        )
    )))
    (merge_impl x y (slice x 0 0)) # This slice creates empty array or tuple.
)))

### Merges two sorted compound structures into a sorted one.
### A default comparator less than assumed.
(bind merge (func (x y) (merge_cmp x y lt)))

### Sorts a compound structure with a custom comparator.
(bind sort_cmp (func (x cmp) (do
    (bind len (length x))
    (bind half_len (/ len 2))
    (if (le len 1)
        x
        (merge_cmp
            (sort_cmp (slice x 0 half_len) cmp)
            (sort_cmp (slice x half_len len) cmp)
            cmp
        )
    )
)))

### Sorts a compound structure with a default comparator: less than.
(bind sort (func (x) (sort_cmp x lt)))

### Function composition
(bind point (func (f g x) (g (f x))))
#(bind point_alter (func (f g) (func (x) (g (f x)))))

### Functional map
(bind map (func (f v)
    (if (empty v)
        (slice v 0 0)
        (cons (f (car v)) (map f (cdr v)))
    )
))
# (bind map_alter (func (f)
#     (foldr (point cons f) [])
# )


### Functional map for two input collections
(bind zip_with (func (f va vb)
    (if (or (empty va) (empty vb))
        (slice va 0 0)
        (cons
            (f (car va) (car vb))
            (zip_with f (cdr va) (cdr vb))
        )
    )
))

### Fold left
(bind foldl (func (f z v)
    (if (empty v)
        z
        (do
            (bind { hd tl } (dcons v))
            (foldl f (f z hd) tl)
        )
    )
))

### Fold right
(bind foldr (func (f z v)
    (if (empty v)
        z
        (do
            (bind { hd tl } (dcons v))
            (f hd (foldr f z tl))
        )
    )
))

### Prints a formatted string
(bind printf (func (fmt args) (print (format fmt args))))

