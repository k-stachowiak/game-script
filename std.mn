# The standard library
# ====================

# Functions filling in for parafunctions
# --------------------------------------

### Binary function realizing the logic of the and parafunc.
(bind f_and (func (x y) (and x y)))

### Binary function realizing the logic of the or parafunc.
(bind f_or (func (x y) (or x y)))

### Unary function realizing the logical negation.
(bind f_not (func (x) (not x)))

# Comparison operators
# --------------------

### Equal in terms of a custom comparator
(bind eq_cmp (func (cmp x y) (and (not (cmp x y)) (not (cmp y x)))))

### Not equal in terms of a custom comparator
(bind ne_cmp (func (cmp x y) (not (eq_cmp cmp x y))))

### Less or equal in terms of a custom comparator
(bind le_cmp (func (cmp x y) (or (cmp x y) (eq_cmp cmp x y))))

### Greater than in terms of a custom comparator
(bind gt_cmp (func (cmp x y) (not (le_cmp cmp x y))))

### Greater than or equal in terms of a custom comparator
(bind ge_cmp (func (cmp x y) (not (cmp x y))))

### Not equal based on the built-in less than comparator
(bind ne (ne_cmp lt))

### Greater than based on the built-in less than comparator
(bind gt (gt_cmp lt))

### Greater than or equal based on the built-in less than comparator
(bind ge (ge_cmp lt))

### Less than or equal based on the built-in less than comparator
(bind le (le_cmp lt))

# Reference operations
# --------------------

### Returns a given reference advanced by n steps
(bind succ_n (func (r^ n) (if (eq n 0) r^ (succ_n (succ r^) (- n 1)))))

### Returns distance between two references
(bind distance (func (first^ last^) (do
    (bind distance_impl (func (first^ last^ counter)
        (if (eq first^ last^)
            counter
            (distance_impl (succ first^) last^ (+ counter 1))
        )
    ))
    (distance_impl first^ last^ 0)
)))

### Swaps values pointed by two references using a temporary object.
(bind swap (func (x^ y^) (do
    (bind temp (peek x^))
    (poke x^ (peek y^))
    (poke y^ temp)
    unit
)))

### Wraps a function operating on a value argument and accepts reference
### instead.
(bind un_ref (func (un x^) (un (peek x^))))

### Wraps a function operating on two value arguments and accepts references
### instead.
(bind bin_ref (func (bin x^ y^) (bin (peek x^) (peek y^))))

# Compound operations
# -------------------

### Checks whether a compound structure is empty
(bind empty (func (x) (eq (length x) 0)))

### Returns the first element of a compound structure
(bind front (func (x) (at x 0)))

### Returns the last element of a compound structure
(bind back (func (x) (at x (- (length x) 1))))

### Returns the compound structure sans the first element
(bind tail (func (x) (slice x 1 (length x))))

### Returns the compound structure sans the last element
(bind rtail (func (x) (slice x 0 (- (length x) 1))))

### Deconstructs compound structure into a tuple containing
### the head and the tail of the input compound structure
(bind dcons (func (x) { (front x) (tail x) }))

### Deconstructs compound structure into a tuple containing
### the tail and the reverse tail of the input compound structure
(bind rdcons (func (x) { (back x) (rtail x) }))

# Functional helpers
# ------------------

### Function composition
(bind point (func (f g x) (g (f x))))

### Functional map
(bind map (func (f v)
    (if (empty v)
        v
        (push_front (map f (tail v)) (f (front v)))
    )
))

### Functional zip
(bind zip (func (vx vy) (do
	(bind zip_impl (func (vx vy result)
		(if (or (empty vx) (empty vy))
			result
			(do
				(bind { hdx tlx } (dcons vx))
				(bind { hdy tly } (dcons vy))
				(zip_impl tlx tly (push_back result { hdx hdy }))
			)
		)
	))
	(zip_impl vx vy [])
)))

### Functional map for two input collections
(bind zip_with (func (f va vb)
    (if (or (empty va) (empty vb))
        (slice va 0 0)
        (push_front
            (zip_with f (tail va) (tail vb))
            (f (front va) (front vb))
        )
    )
))

### Fold left
(bind foldl (func (f z v)
    (if (empty v)
        z
        (do
            (bind { hd tl } (dcons v))
            (foldl f (f z hd) tl)
        )
    )
))

### Fold right
(bind foldr (func (f z v)
    (if (empty v)
        z
        (do
            (bind { hd tl } (dcons v))
            (f hd (foldr f z tl))
        )
    )
))

# Algorithms
# ----------

### Returns the lesser of the two arguments based on the provided less than operator
(bind min_cmp (func (cmp x y) (if (cmp x y) x y)))

### Returns the lesser of the two arguments based on the less than operator
(bind min (min_cmp lt))

### Returns the greager of the two arguments based on the provided less than operator
(bind max_cmp (func (cmp x y) (if (cmp x y) y x)))

### Returns the greater of the two arguments based on the less than operator
(bind max (max_cmp lt))

### min_cmp variant operating on references
(bind min_ref_cmp (func (cmp x^ y^) (if (cmp (peek x^) (peek y^)) x^ y^)))

### min variant operating on references
(bind min_ref (min_ref_cmp lt))

### max_cmp variant operating on references
(bind max_ref_cmp (func (cmp x^ y^) (if (cmp (peek x^) (peek y^)) y^ x^)))

### max variant operating on references
(bind max_ref (max_ref_cmp lt))

### Asserts if all of elements in range fulfill a given predicate
(bind all_of (func (pred first^ last^)
	(if (eq first^ last^)
		true
		(if (pred (peek first^))
			(all_of pred (succ first^) last^)
			false
		)
	)
))

### Asserts if any of elements in range fulfills a given predicate
(bind any_of (func (pred first^ last^)
	(if (eq first^ last^)
		false
		(if (pred (peek first^))
			true
			(any_of pred (succ first^) last^)
		)
	)
))

### Asserts if none of elements in range don't fulfill a given predicate
(bind none_of (func (pred first^ last^) (all_of (point pred not) first^ last^) ))

### Finds the minimum element in a compound structure with a custom comparator
(bind min_element_cmp (func (cmp first^ last^) (do
    (bind min_element_impl (func (current_min^ first^ last^)
        (if (eq first^ last^)
            current_min^
            (min_element_impl
                (min_ref_cmp cmp current_min^ first^)
                (succ first^)
                last^
            )
        )
    ))
    (bind len (distance first^ last^))
    (if (eq len 0)
        last^
        (if (eq len 1)
            first^
            (min_element_impl first^ (succ first^) last^)
        )
    )
)))

### Finds the minimum element in a compound structure with a
### default comparator: less than
(bind min_element (min_element_cmp lt))

### Finds a reference to the first element in range that satisfies the provided
### predicate.
(bind find_if (func (first^ last^ pred)
    (if (or (eq first^ last^) (pred (peek first^)))
        first^
        (find_if (succ first^) last^ pred)
    )
))

### Finds a reference to the first element in range that doesn't satisfy
### the provided predicate.
(bind find_if_not (func (first^ last^ pred)
    (find_if first^ last^ (point pred not))
))

### Attempts to find a value in the given range
(bind find (func (first^ last^ value) (find_if first^ last^ (eq value))))

### Lexicographical compare for compound types with a custom compare operation
(bind lexicographical_compare_cmp(func (cmp first1^ last1^ first2^ last2^) (do
    (bind cmp_ref (bin_ref cmp))
    (if (or (eq first1^ last1^) (eq first2^ last2^))
        (and (eq first1^ last1^) (ne first2^ last2^))
        (if (cmp_ref first1^ first2^)
            true
            (if (cmp_ref first2^ first1^)
                false
                (lexicographical_compare_cmp cmp
                    (succ first1^) (succ first2^)
                    last1^ last2^)
            )
        )
    )
)))

### Lexicographical compare for compound types with a less than operator used
### for comparison
(bind lexicographical_compare (lexicographical_compare_cmp lt))

### Rearranges elements that all of them that fulfill the predicate end up
### between first and the returned references, and all others end up between
### the returned and the last references. Accepts custom comparator.
(bind partition (func (pred first^ last^) (do
    (bind mismatch^ (find_if_not first^ last^ pred))
    (if (eq mismatch^ last^)
        last^
        (do
            (bind match^ (find_if mismatch^ last^ pred))
            (if (eq match^ last^)
                mismatch^
                (do
                    (swap mismatch^ match^)
                    (partition pred (succ mismatch^) last^)
                )
            )
        )
    )
)))

### Inplace quicksort implementation accepting custom comparator
(bind quicksort_cmp (func (cmp first^ last^)
    (if (eq first^ last^)
		unit
        (do
            (bind pivot (peek (succ_n first^ (/ (distance first^ last^) 2))))

            (bind lt_pivot (gt_cmp cmp pivot))
            (bind eq_pivot (eq_cmp cmp pivot))

            (bind middle1^ (partition lt_pivot first^ last^))
            (bind middle2^ (partition eq_pivot middle1^ last^))

            (quicksort_cmp cmp first^ middle1^)
            (quicksort_cmp cmp middle2^ last^)

            unit
        )
    )
))

### Quicksort algorithm variant for the default less than comparator
(bind quicksort (quicksort_cmp lt))

### Default sorting function accepting a comparison function as an argument.
(bind sort_cmp quicksort_cmp)

### Default sorting function with the comparison defaulted to less than.
(bind sort (sort_cmp lt))

# Compound generators
# -------------------

### Produce sequence of first n natural numbers (including 0).
(bind seq (func (n) (do
	(bind seq_impl (func (current last acc)
		(if (eq current last)
			acc
			(seq_impl (+ current 1) last (push_back acc current))
		)
	))
	(seq_impl 0 n [])
)))

### Returns an array containing a range of integer values
(bind range_int (func (init count) (do
	(map (+ init) (seq count))
)))

# Text related
# ------------

### Prints a formatted string
(bind printf (func (fmt args) (print (format fmt args))))

# Automatic testing
# -----------------

(bind test (func (case result)
    (if result true (do (printf "Test \"%s\" failed\n" { case }) false))
))

(bind std_test (func ()
    (foldl f_and true [

        # Comparisons
        (test "Not equal 1" (eq (ne 1 2) true))
        (test "Not equal 2" (eq (ne 3 3) false))
        (test "Greater than 1" (eq (gt 3 2) true))
        (test "Greater than 2" (eq (gt 2 3) false))
        (test "Greater than or equal 1" (eq (ge 3 2) true))
        (test "Greater than or equal 2" (eq (ge 3 3) true))
        (test "Greater than or equal 3" (eq (ge 3 4) false))
        (test "Less than or equal 1" (eq (le 2 3) true))
        (test "Less than or equal 2" (eq (le 3 3) true))
        (test "Less than or equal 3" (eq (le 4 3) false))

        # References
        (test "Nth successor" (do
            (bind v [ 1 2 3 ])
            (bind tedious (succ (succ (begin v))))
            (bind easy (succ_n (begin v) 2))
            (and (eq tedious easy) (eq (peek tedious) (peek easy)))
        ))

        (test "Reference distance" (do
            (bind v [ 1 2 3 ])
            (eq (distance (begin v) (end v)) (length v))
        ))

        (test "Swap test" (do
            (bind x [ 1.0 2.0 3.0 ])
            (bind y [ 3.0 2.0 1.0 ])
            (swap (ref x) (ref y))
            (and (eq x [ 3.0 2.0 1.0 ]) (eq y [ 1.0 2.0 3.0 ]))
        ))

        (test "Unary reference" (do
            (bind x 2)
            (bind v [ x ])
            (bind sqr (func (x) (* x x)))
            (bind sqr_ref (un_ref sqr))
            (bind x_sqr (sqr x))
            (bind x_ref_sqr (sqr_ref (begin v)))
            (eq x_sqr x_ref_sqr)
        ))

        (test "Binary reference" (do
            (bind x 2)
            (bind y 3)
            (bind v [ x y ])
            (bind plus_ref (bin_ref +))
            (bind sum (+ x y))
            (bind ref_sum (plus_ref (begin v) (succ (begin v))))
            (eq sum ref_sum)
        ))

        # Compound clunky
        (test "String = array" (eq "string" [ 's' 't' 'r' 'i' 'n' 'g' ]))
        (test "Empty 1" (eq (empty []) true))
        (test "Empty 2" (eq (empty { 'a' }) false))
        (test "Empty 3" (eq (empty "") true))
        (test "Front 1" (eq (front [ 'a' ]) 'a'))
        (test "Front 2" (eq (front { 1.0 2.0 3.0 }) 1.0))
        (test "Back 1" (eq (back [ 'a' ]) 'a'))
        (test "Back 2" (eq (back [ 1.0 2.0 3.0 ]) 3.0))
        (test "Tail 1" (eq (tail { 'a' }) {}))
        (test "Tail 2" (eq (tail [ 1.0 2.0 3.0 ]) [ 2.0 3.0 ]))
        (test "Tail 3" (eq (tail "asd") "sd"))
        (test "Reverse tail 1" (eq (rtail { 'a' }) {}))
        (test "Reverse tail 2" (eq (rtail [ 1.0 2.0 3.0 ]) [ 1.0 2.0 ]))
        (test "Reverse tail 3" (eq (rtail "asd") "as"))
        (test "Deconstruct 1" (eq (dcons [ 1 2 3 ]) { 1 [ 2 3 ] }))
        (test "Deconstruct 2" (eq (dcons [ true ]) { true [] }))
        (test "Reverse deconstruct 1" (eq (rdcons [ 1 2 3 ]) { 3 [ 1 2 ] }))
        (test "Reverse deconstruct 2" (eq (rdcons [ true ]) { true [] }))

        # Functional
        (test "Point 1" (do (bind cadr (point tail front)) (eq (cadr [ 1 2 3 ]) 2)))
        (test "Point 2" (do
            (bind times2 (* 2))
            (bind times4 (point times2 times2))
            (bind times8 (point times2 times4))
            (eq (times8 3) (* 3 8))
        ))
        (test "Map" (eq (map not [ true false true ]) [ false true false ]))
		(test "Zip normal" (eq (zip [ 1 2 3 ] [ 'a' 'b' 'c' ]) [ { 1 'a' } { 2 'b' } { 3 'c' } ]))
		(test "Zip count mismatch" (eq (zip [ 1 2 3 ] [ 'a' 'b' ]) [ { 1 'a' } { 2 'b' } ]))
		(test "Zip with empty" (eq (zip [ 1 2 3 ] []) []))
        (test "Zip with" (eq (zip_with * [ 1 2 3 ] [ 4 5 6 ]) [ 4 10 18 ]))
        (test "Fold left" (eq (foldl - 0 [ 1 2 3 4 5 6 7 8 9 10 ]) -55))
        (test "Fold right" (eq (foldr - 0 [ 1 2 3 4 5 6 7 8 9 10 ]) -5))

        # Algorithms simple
        (test "Min 1" (eq (min_cmp gt 1 2) 2))
        (test "Min 2" (eq (min_cmp lt 1 2) 1))
        (test "Min 3" (eq (min 5.0 500.0) 5.0))
        (test "Max 1" (eq (max_cmp gt 1 2) 1))
        (test "Max 2" (eq (max_cmp lt 1 2) 2))
        (test "Max 3" (eq (max 5.0 500.0) 500.0))

        # Algorithms compound reference

		(test "All of" (do
			(bind v [ 1 2 3 ])
			(all_of (ge 3) (begin v) (end v))
		))

		(test "Any of 1" (do
			(bind v [ 1 2 3 ])
			(any_of (eq 2) (begin v) (end v))
		))
		(test "Any of 2" (do
			(bind v [ 1 2 3 ])
			(not (any_of (eq 5) (begin v) (end v)))
		))

		(test "None of" (do
			(bind v [ 1 2 3 ])
			(none_of (lt 3) (begin v) (end v))
		))

        (test "Min element 1" (do
            (bind v [ 1 2 3])
            (bind result_gt^ (min_element_cmp gt (begin v) (end v)))
            (eq (peek result_gt^) 3)
        ))
        (test "Min element 2" (do
            (bind v [ 1 2 3])
            (bind result_lt^ (min_element (begin v) (end v)))
            (eq (peek result_lt^) 1)
        ))

        (test "Find if 1" (do
            (bind v "asdf")
            (bind result^ (find_if (begin v) (end v) (eq 'd')))
            (eq (peek result^) 'd')
        ))
        (test "Find if 2" (do
            (bind v "asdf")
            (bind result^ (find_if (begin v) (end v) (eq 'z')))
            (eq result^ (end v))
        ))

        (test "Find if not 1" (do
            (bind v [ 2 4 6 8 ])
            (bind result^ (find_if_not (begin v) (end v) (ge 5)))
            (eq (peek result^) 6)
        ))
        (test "Find if not 2" (do
            (bind v { 1.0 2.0 3.0 4.0 })
            (bind result^ (find_if_not (begin v) (end v) (ge 5.0)))
            (eq result^ (end v))
        ))

        (test "Find 1" (do
            (bind v "asdf")
            (bind result^ (find (begin v) (end v) 'd'))
            (eq (peek result^) 'd')
        ))
        (test "Find 2" (do
            (bind v "asdf")
            (bind result^ (find (begin v) (end v) 'z'))
            (eq result^ (end v))
        ))

		(test "Partition empty" (do
			(bind v [ 1 ])
			(bind pred (eq 1))
			(bind result^ (partition pred (begin v) (end v)))
			(eq result^ (end v))
		))
        (test "Partition mixed" (do
            (bind v [ 1 4 5 3 2 6 ])
			(bind pred (ge 3))
			(bind first^ (begin v))
			(bind last^ (end v))
            (bind result^ (partition pred first^ last^))
			(and
				(all_of pred first^ result^)
				(none_of pred result^ last^)
			)
        ))

        (test "Lexicographical compare" (do
            (bind x "Adam")
            (bind y "Beata")
            (and
                (lexicographical_compare (begin x) (end x) (begin y) (end y))
                (not (lexicographical_compare (begin y) (end y) (begin x) (end x)))
            )
        ))

        (test "Quicksort 1" (do
			(bind unsorted [ 5 1 4 2 3 ])
			(bind sorted [ 5 4 3 2 1 ])
			(quicksort_cmp gt (begin unsorted) (end unsorted))
			(eq sorted unsorted)
		))
		(test "Quicksort 2" (do
			(bind unsorted [ 5 1 4 2 3 ])
			(bind sorted [ 1 2 3 4 5 ])
			(quicksort (begin unsorted) (end unsorted))
			(eq sorted unsorted)
		))

		# Sequences
		(test "Sequence empty" (eq (seq 0) []))
		(test "Sequence non-empty" (eq (seq 5) [ 0 1 2 3 4 ]))
		(test "Integer range empty" (eq (range_int 0 0) []))
		(test "Integer range positive" (eq (range_int 0 4) [ 0 1 2 3 ]))
		(test "Integer range not only positive" (eq (range_int -2 4) [ -2 -1 0 1 ]))
    ])
))

