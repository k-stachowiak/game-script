# The standard library
# ====================

# Functions filling in for parafunctions
# --------------------------------------

### Binary function realizing the logic of the and parafunc.
(bind f_and (func (x y) (and x y)))

### Binary function realizing the logic of the or parafunc.
(bind f_or (func (x y) (or x y)))

# Comparison operators
# --------------------

### Not equal in terms of equality
(bind ne (func (x y) (not (eq x y))))

### Greater than implemented in terms of less than and non-equality
(bind gt (func (x y) (lt y x)))

### Greater or equal implemented in terms of less than
(bind ge (func (x y) (not (lt x y))))

### Less or equal implemented in terms of greater than
(bind le (func (x y) (not (gt x y))))

# Compound operations
# -------------------

### Checks whether a compound structure is empty
(bind empty (func (x) (eq (length x) 0)))

### Returns the first element of a compound structure
(bind car (func (x) (at x 0)))

### Returns the compound structure sans the first element
(bind cdr (func (x) (slice x 1 (length x))))

### Returns the first element of a compound structure
(bind front (func (x) (at x 0)))

### Returns the last element of a compound structure
(bind back (func (x) (at x (- (length x) 1))))

### Constructs a new compound value from an element and an existing compound
(bind cons (func (x arr) (push_front arr x)))

### Deconstructs compound structure into a tuple containing
### the head and the tail of the input compound structure
(bind dcons (func (x) { (car x) (cdr x) }))

# Algorithms
# ----------

### Returns the lesser of the two arguments based on the provided less than operator
(bind min_cmp (func (cmp x y) (if (cmp x y) x y)))

### Returns the lesser of the two arguments based on the less than operator
(bind min (min_cmp lt))

### Returns the greager of the two arguments based on the provided less than operator
(bind max_cmp (func (cmp x y) (if (cmp x y) y x)))

### Returns the greater of the two arguments based on the less than operator
(bind max (max_cmp lt))

### Finds the minimum element in a compound structure with a custom comparator
(bind min_element_cmp (func (cmp x) (do
    (bind min_element_impl (func (element x)
        (if (empty x)
            element
            (if (cmp element (car x))
                (min_element_impl element (cdr x))
                (min_element_impl (car x) (cdr x))
            )
        )
    ))
    (if (eq (length x) 1)
        (car x)
        (min_element_impl (car x) (cdr x))
    )
)))

### Finds the minimum element in a compound structure with a
### default comparator: less than
(bind min_element (min_element_cmp lt))

### Merges two sorted compound structures into a sorted one
### with a custom comparator
(bind merge_cmp (func (cmp x y) (do
    (bind merge_impl (func (x y result) (do
        (bind x_empty (empty x))
        (bind y_empty (empty y))
        (if x_empty
            (if y_empty result (cat result y))
            (if y_empty
                (cat result x)
                (if (cmp (car x) (car y))
                    (merge_impl (cdr x) y (push_back result (car x)))
                    (merge_impl x (cdr y) (push_back result (car y)))
                )
            )
        )
    )))
    (merge_impl x y (slice x 0 0)) # This slice creates empty array or tuple.
)))

### Merges two sorted compound structures into a sorted one.
### A default comparator less than assumed.
(bind merge (merge_cmp lt))

### Merge-sorts a compound structure with a custom comparator.
(bind merge_sort_cmp (func (cmp x) (do
    (bind len (length x))
    (bind half_len (/ len 2))
    (if (le len 1)
        x
        (merge_cmp
            cmp
            (merge_sort_cmp cmp (slice x 0 half_len))
            (merge_sort_cmp cmp (slice x half_len len))
        )
    )
)))

### Merge-sorts a compound structure with a default comparator: less than.
(bind merge_sort (merge_sort_cmp lt))

### Default sorting function accepting a comparison function as an argument.
(bind sort_cmp merge_sort_cmp)

### Default sorting function with the comparison defaulted to less than.
(bind sort (sort_cmp lt))

# Functional helpers
# ------------------

### Function composition
(bind point (func (f g x) (g (f x))))

### Functional map
(bind map (func (f v)
    (if (empty v)
        v
        (cons (f (car v)) (map f (cdr v)))
    )
))

### Functional map for two input collections
(bind zip_with (func (f va vb)
    (if (or (empty va) (empty vb))
        (slice va 0 0)
        (cons
            (f (car va) (car vb))
            (zip_with f (cdr va) (cdr vb))
        )
    )
))

### Fold left
(bind foldl (func (f z v)
    (if (empty v)
        z
        (do
            (bind { hd tl } (dcons v))
            (foldl f (f z hd) tl)
        )
    )
))

### Fold right
(bind foldr (func (f z v)
    (if (empty v)
        z
        (do
            (bind { hd tl } (dcons v))
            (f hd (foldr f z tl))
        )
    )
))

# Text related
# ------------

### Prints a formatted string
(bind printf (func (fmt args) (print (format fmt args))))

### Returns a sequence of n first natural numbers (including 0)
(bind seq (func (n) (do
	(bind seq_impl (func (first last acc)
		(if (eq first last)
			acc
			(seq_impl (+ first 1) last (push_back acc first))
		)
    ))
	(seq_impl 0 n [])
)))

# Automatic testing
# -----------------

(bind test (func (case result)
    (if result true (do (printf "Test \"%s\" failed\n" { case }) false))
))

(bind std_test (func ()
    (foldl f_and true [

        # Comparisons
        (test "Not equal 1" (eq (ne 1 2) true))
        (test "Not equal 2" (eq (ne 3 3) false))
        (test "Greater than 1" (eq (gt 3 2) true))
        (test "Greater than 2" (eq (gt 2 3) false))
        (test "Greater than or equal 1" (eq (ge 3 2) true))
        (test "Greater than or equal 2" (eq (ge 3 3) true))
        (test "Greater than or equal 3" (eq (ge 3 4) false))
        (test "Less than or equal 1" (eq (le 2 3) true))
        (test "Less than or equal 2" (eq (le 3 3) true))
        (test "Less than or equal 3" (eq (le 4 3) false))

        # Compound
        (test "String = array" (eq "string" [ 's' 't' 'r' 'i' 'n' 'g' ]))
        (test "Empty 1" (eq (empty []) true))
        (test "Empty 2" (eq (empty { 'a' }) false))
        (test "Empty 3" (eq (empty "") true))
        (test "Car 1" (eq (car [ 'a' ]) 'a'))
        (test "Car 2" (eq (car [ 1.0 2.0 3.0 ]) 1.0))
        (test "Cdr 1" (eq (cdr { 'a' }) {}))
        (test "Cdr 2" (eq (cdr [ 1.0 2.0 3.0 ]) [ 2.0 3.0 ]))
        (test "Cdr 3" (eq (cdr "asd") "sd"))
        (test "Front 1" (eq (front [ 'a' ]) 'a'))
        (test "Front 2" (eq (front { 1.0 2.0 3.0 }) 1.0))
        (test "Back 1" (eq (back [ 'a' ]) 'a'))
        (test "Back 2" (eq (back [ 1.0 2.0 3.0 ]) 3.0))
        (test "Cons 1" (eq (cons 'a' []) [ 'a' ]))
        (test "Cons 2" (eq (cons "ene" [ "due" "rabe" ]) [ "ene" "due" "rabe" ]))
        (test "Cons 3" (eq (cons 'a' "sd") "asd"))
        (test "DCons 1" (eq (dcons [ 1 2 3 ]) { 1 [ 2 3 ] }))
        (test "DCons 2" (eq (dcons [ true ]) { true [] }))

        # Algorithms
        (test "Min 1" (eq (min_cmp gt 1 2) 2))
        (test "Min 2" (eq (min_cmp lt 1 2) 1))
        (test "Min 3" (eq (min 5.0 500.0) 5.0))
        (test "Max 1" (eq (max_cmp gt 1 2) 1))
        (test "Max 2" (eq (max_cmp lt 1 2) 2))
        (test "Max 3" (eq (max 5.0 500.0) 500.0))
        (test "Min element 1" (eq (min_element_cmp gt [ 1 2 3 ]) 3))
        (test "Min element 2" (eq (min_element [ 1.0 2.0 3.0 ]) 1.0))
        (test "Merge 1" (eq (merge_cmp gt [ 5 3 1 ] [ 6 4 2 ]) [ 6 5 4 3 2 1 ]))
        (test "Merge 2" (eq (merge [ 1 3 5 ] [ 2 4 6 ]) [ 1 2 3 4 5 6 ]))
        (test "Sort 1" (eq (merge_sort_cmp gt [ 5 1 4 2 3 ]) [ 5 4 3 2 1 ]))
        (test "Sort 2" (eq (merge_sort [ 5 1 4 2 3 ]) [ 1 2 3 4 5 ]))

        # Functional
        (test "Point" (do (bind cadr (point cdr car)) (eq (cadr [ 1 2 3 ]) 2)))
        (test "Map" (eq (map not [ true false true ]) [ false true false ]))
        (test "Zip with" (eq (zip_with * [ 1 2 3 ] [ 4 5 6 ]) [ 4 10 18 ]))
        (test "Fold left" (eq (foldl - 0 [ 1 2 3 4 5 6 7 8 9 10 ]) -55))
        (test "Fold right" (eq (foldr - 0 [ 1 2 3 4 5 6 7 8 9 10 ]) -5))
    ])
))

